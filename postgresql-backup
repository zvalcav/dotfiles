#!/bin/bash
#postgresql-backup
#provadi postgresql dumpy zvolenych databazi
#version 1.0


#LIST
#_PROMENNE
#_EXITY
#_LOGOVANI
#_PODMINKY
#_KONFIGURACE
#_POSTGRESQL_BACKUP_CRON
#_ZALOHA


#_PROMENNE
scriptName="postgresql-backup"
backupDir="/var/backup/postgresql"
backupLimit=14
todayDate="$(date +%F)"
todayDateTime="$(date +%F_%H-%M)"

scriptDir="/usr/local/bash-scripts"
verbose=0
deBug=0

#_EXITY
#exit 1		#disablovany script
#exit 2		#spatne nastavena nektera z promennych


#_LOGOVANI

#nacteni definice funkci Log,LogError,RvLog,MailSend z knihovny
. $scriptDir/funkce	
Log "script ($scriptName) - zacatek"
echo "$$" > "$startFile"
Log "($startFile) set to ($$)"

#_KONFIGURACE
#zapise konfiguracni soubor, ze ktereho bude nasledne nacitat hodnoty
write(){
	if [ -f "$configFile" ]
	then
		cp "$configFile" "${configFile}.back"
		RvLog "provedena zaloha konfigurace do (${configFile}.back)"
	fi
	{
	echo "#vypne/zapne (1/0) provadeni scriptu"
	echo "disabled=1"
	echo "#nastavuje, kolik zaloh zpetne se bude drzet"
	echo "backupLimit=14"
	echo "#uzivatel, pod kterym se budou provadet dumpy... v pripade vice databazi musi byt postgres"
	echo "postgresqlUser=\"postgres\""
	echo "#heslo uzivatele pro postgresql"
	echo "postgresqlPassword=\"\""
	} > "$configFile"
	LogError "zapsan konfiguracni soubor pro server ($HOSTNAME)"
}



#nacte konfiguracni soubor
if [ -f "$configFile" ]
then
	. "$configFile"
	Log "nacten konfiguracni soubor ($configFile)"
else
	write
	. "$configFile"
fi


#nastavenim disabled na 1 se vypne spousteni scriptu, uprav $configFile, mail se neposila
if [ "$disabled" -eq 1 ]
then
	Log "script ($scriptName) byl disablovan v konfiguracnim souboru ($configFile)"
	MailSend
	exit 1
fi


#kontrola nastaveni promennych 
if [ -z "$backupLimit" ] || [ -z "$postgresqlUser" ] || [ -z "$backupDir" ]
then
	LogError "nebyla nastavena nektera z promennych backupLimit=($backupLimit), postgresqlUser=($postgresqlUser), postgresqlPassword=($postgresqlPassword), backupDir=($backupDir)"
	MailSend
	exit 2
else
	export PGPASSWORD="$postgresqlPassword"
fi

#_POSTGRESQL_BACKUP_CRON
#pokud neni zaznam pro postgresql-backup
if [ ! -e /etc/cron.d/postgresql-backup ]
then
	#vytvori radek, ktery spousti dany script ve 2:00 a kompletni debug vystup se uklada do souboru ve /var/log
	{ 
		echo "#denni spousteni postgresql-backup"
		echo "0 1 * * * root $sbinDir/postgresql-backup &>$outputFile"
	} > /etc/cron.d/postgresql-backup
	RvLog "zapsano spousteni postgresql-backup scriptu do cronu"
fi

#_ZALOHA
#vycteni databazi z postgresql do pole
#-w se nepta na heslo, ale musi byt nastavena promenna PGPASSWORD
#-At vynecha kudrlinky
#-c prikaz predany postgresql
backupARRAY=($(psql -U"$postgresqlUser" -w -At -c "select datname from pg_database where not datistemplate and datallowconn order by datname;"))
RvLog "nastaveno pole backupARRAY (${backupARRAY[@]})"


#provede dumpy vsech existujicich databazi
for database in ${backupARRAY[@]}
do
	backupName="$database-${todayDateTime}.zip"
	backupNameSql="$database-${todayDateTime}.sql"
	backupPath="$backupDir/$database/$todayDate"
	CheckDir "$backupPath"

	#provede dump databaze
	if [[ "$database" =~ "zabbix" ]]
	then
		# pokud nazev databaze obsahuje zabbix, provede dump s vynechanim tabulek history a trends - obnovovani je potreba doplnit o soubor history_trends_create.sql z /usr/local/src/zabbix-monitoring/database/postgresql
		pg_dump -U"$postgresqlUser"  -T 'history*' -T 'trends*' -w "$database" --file="$backupPath/$backupNameSql" > /dev/null
		RvLog "Vytvoren postgresql-dump databaze s nazvem ($backupPath/$backupNameSql)"

		# nacte navratovou hodnotu - funkce RvLog ji vraci
		rv="$?"

		# doplni definici chybejicich tabulek do backupu
		cat "$scriptDir/history_trends.sql" >> "$backupPath/$backupNameSql"

		RvLog "Doplneno vytvareni tabulek history a trends do zalohy ($backupPath/$backupNameSql)"
	else
		# bezne zalohovani bez vynechavani
		pg_dump -U"$postgresqlUser" -w "$database" --file="$backupPath/$backupNameSql" > /dev/null

		RvLog "Vytvoren postgresql-dump databaze s nazvem ($backupPath/$backupNameSql)"

		# nacte navratovou hodnotu - funkce RvLog ji vraci
		rv="$?"
	fi

	# pokud byl dump uspesny
	if [ "$rv" -eq 0 ] && cd "$backupPath"
	then
		#-T otestuje archiv a --move po uspesnem testu soubor smaze
		zip -T --move "$backupName" "$backupNameSql" > /dev/null
		RvLog "postgresql-dump uspesne zkomprimovan ($backupName)"

		# pokud bylo zazipovani uspesne
		if [ "$?" -eq 0 ]
		then
			#odstraneni zaloh starsich nez $backupLimit
			find "$backupDir/$database" -maxdepth 1 -mindepth 1 -type d -mtime +"$backupLimit" -exec rm -rf {} \;
			RvLog "odstraneni starych zaloh z ($backupPath)"
		fi
	fi
done

unset PGPASSWORD

MailSend
exit 0
